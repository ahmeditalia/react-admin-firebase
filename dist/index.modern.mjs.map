{"version":3,"file":"index.modern.mjs","sources":["../src/misc/arrayHelpers.ts","../src/misc/objectFlatten.ts","../src/misc/logger/logger-base.ts","../src/misc/logger/firestore-logger.ts","../src/misc/logger/logger.ts","../src/misc/dispatcher.ts","../src/misc/internal.models.ts","../src/misc/translate-from-firestore.ts","../src/misc/document-parser.ts","../src/misc/pathHelper.ts","../src/misc/translate-to-firestore.ts","../src/providers/database/firebase/FirebaseWrapper.ts","../src/providers/AuthProvider.ts","../src/misc/status-code-translator.ts","../src/providers/database/ResourceManager.ts","../src/providers/database/FireClient.ts","../src/misc/storage-parser.ts","../src/misc/metadata-parser.ts","../src/misc/firebase-models.ts","../src/providers/lazy-loading/queryCursors.ts","../src/providers/lazy-loading/paramsToQuery.ts","../src/providers/lazy-loading/FirebaseLazyLoadingClient.ts","../src/providers/DataProvider.ts","../src/providers/queries/GetList.ts","../src/providers/queries/GetOne.ts","../src/providers/queries/GetMany.ts","../src/providers/queries/GetManyReference.ts","../src/providers/commands/Update.ts","../src/providers/commands/UpdateMany.ts","../src/providers/commands/Create.ts","../src/providers/commands/Delete.ts","../src/providers/commands/Delete.Soft.ts","../src/providers/commands/DeleteMany.ts","../src/providers/commands/DeleteMany.Soft.ts"],"sourcesContent":["import { get, isEmpty } from 'lodash';\r\nimport { getFieldReferences, SearchObj } from './objectFlatten';\r\n\r\nexport function sortArray(\r\n  data: Array<{}>,\r\n  field: string,\r\n  dir: 'asc' | 'desc'\r\n): void {\r\n  data.sort((a: {}, b: {}) => {\r\n    const rawA = get(a, field);\r\n    const rawB = get(b, field);\r\n    const isAsc = dir === 'asc';\r\n\r\n    const isNumberField = Number.isFinite(rawA) && Number.isFinite(rawB);\r\n    if (isNumberField) {\r\n      return basicSort(rawA, rawB, isAsc);\r\n    }\r\n    const isStringField = typeof rawA === 'string' && typeof rawB === 'string';\r\n    if (isStringField) {\r\n      const aParsed = rawA.toLowerCase();\r\n      const bParsed = rawB.toLowerCase();\r\n      return basicSort(aParsed, bParsed, isAsc);\r\n    }\r\n    const isDateField = rawA instanceof Date && rawB instanceof Date;\r\n    if (isDateField) {\r\n      return basicSort(rawA, rawB, isAsc);\r\n    }\r\n    return basicSort(!!rawA, !!rawB, isAsc);\r\n  });\r\n}\r\n\r\nfunction basicSort(aValue: any, bValue: any, isAsc: boolean) {\r\n  if (aValue > bValue) {\r\n    return isAsc ? 1 : -1;\r\n  }\r\n  if (aValue < bValue) {\r\n    return isAsc ? -1 : 1;\r\n  }\r\n  return 0;\r\n}\r\n\r\nexport function filterArray(\r\n  data: Array<{}>,\r\n  searchFields?: { [field: string]: string | number | boolean | null }\r\n): Array<{}> {\r\n  if (!searchFields || isEmpty(searchFields)) {\r\n    return data;\r\n  }\r\n  const searchObjs: SearchObj[] = [];\r\n  Object.keys(searchFields).map((fieldName) => {\r\n    const fieldValue = searchFields[fieldName];\r\n    const getSubObjects = getFieldReferences(fieldName, fieldValue);\r\n    searchObjs.push(...getSubObjects);\r\n  });\r\n  const filtered = data.filter((row) =>\r\n    searchObjs.reduce((acc, cur) => {\r\n      const res = doesRowMatch(row, cur.searchField, cur.searchValue);\r\n      return res && acc;\r\n    }, true as boolean)\r\n  );\r\n  return filtered;\r\n}\r\n\r\nexport function doesRowMatch(\r\n  row: {},\r\n  searchField: string,\r\n  searchValue: any\r\n): boolean {\r\n  const searchThis = get(row, searchField);\r\n  const bothAreFalsey = !searchThis && !searchValue;\r\n  if (bothAreFalsey) {\r\n    return true;\r\n  }\r\n  const nothingToSearch = !searchThis;\r\n  if (nothingToSearch) {\r\n    return false;\r\n  }\r\n  const isStringSearch = typeof searchValue === 'string';\r\n  if (isStringSearch) {\r\n    return searchThis\r\n      .toString()\r\n      .toLowerCase()\r\n      .includes(searchValue.toLowerCase());\r\n  }\r\n  const isBooleanOrNumber =\r\n    typeof searchValue === 'boolean' || typeof searchValue === 'number';\r\n  if (isBooleanOrNumber) {\r\n    return searchThis === searchValue;\r\n  }\r\n  const isArraySearch = Array.isArray(searchValue);\r\n  if (isArraySearch) {\r\n    return searchValue.includes(searchThis);\r\n  }\r\n  return false;\r\n}\r\n","type SearchValues = {} | number | string | boolean | null;\r\ntype SearchValue = SearchValues | SearchValue[];\r\n\r\nexport interface SearchObj {\r\n  searchField: string;\r\n  searchValue: SearchValue;\r\n}\r\nexport function getFieldReferences(\r\n  fieldName: string,\r\n  value: {} | SearchValue\r\n): SearchObj[] {\r\n  const isFalsy = !value;\r\n  const isSimple =\r\n    isFalsy ||\r\n    typeof value === 'string' ||\r\n    typeof value === 'number' ||\r\n    typeof value === 'boolean';\r\n\r\n  if (isSimple) {\r\n    return [\r\n      {\r\n        searchField: fieldName,\r\n        searchValue: value as SearchValue,\r\n      },\r\n    ];\r\n  }\r\n  const tree = {} as Record<string, SearchValue>;\r\n  tree[fieldName] = value;\r\n  return objectFlatten(tree);\r\n}\r\n\r\nexport function objectFlatten(tree: {}): SearchObj[] {\r\n  var leaves: SearchObj[] = [];\r\n  var recursivelyWalk = (obj: any, path: string | null) => {\r\n    path = path || '';\r\n    for (var key in obj) {\r\n      if (obj.hasOwnProperty(key)) {\r\n        const objVal = obj && obj[key];\r\n        const currentPath = !!path ? path + '.' + key : key;\r\n        const isWalkable =\r\n          typeof objVal === 'object' || objVal instanceof Array;\r\n        if (isWalkable) {\r\n          recursivelyWalk(objVal, currentPath);\r\n        } else {\r\n          leaves.push({ searchField: currentPath, searchValue: objVal });\r\n        }\r\n      }\r\n    }\r\n  };\r\n  recursivelyWalk(tree, null);\r\n  return leaves;\r\n}\r\n","type LogFn = (...args: any) => void;\r\n\r\nexport const LogNoOp: LogFn = (...args: any) => null;\r\n\r\nexport class LoggerBase {\r\n  constructor(private title: string, private cacheEnabledKey: string) {}\r\n\r\n  private isEnabled() {\r\n    return !!localStorage.getItem(this.cacheEnabledKey);\r\n  }\r\n\r\n  SetEnabled(isEnabled: boolean) {\r\n    if (isEnabled) {\r\n      localStorage.setItem(this.cacheEnabledKey, 'true');\r\n    } else {\r\n      localStorage.removeItem(this.cacheEnabledKey);\r\n    }\r\n  }\r\n\r\n  public get log() {\r\n    if (!this.isEnabled()) {\r\n      return LogNoOp;\r\n    }\r\n    const boundLogFn: (...args: any) => void = console.log.bind(\r\n      console,\r\n      this.title\r\n    );\r\n    return boundLogFn;\r\n  }\r\n\r\n  public get warn() {\r\n    if (!this.isEnabled()) {\r\n      return LogNoOp;\r\n    }\r\n    const boundLogFn: (...args: any) => void = console.warn.bind(\r\n      console,\r\n      this.title\r\n    );\r\n    return boundLogFn;\r\n  }\r\n\r\n  public get error() {\r\n    if (!this.isEnabled()) {\r\n      return LogNoOp;\r\n    }\r\n    const boundLogFn: (...args: any) => void = console.error.bind(\r\n      console,\r\n      this.title\r\n    );\r\n    return boundLogFn;\r\n  }\r\n}\r\n","import { RAFirebaseOptions } from 'providers/options';\r\nimport { LoggerBase, LogNoOp } from './logger-base';\r\n\r\nconst LOGGER_ENABLEDKEY = 'LOGGING_FIRESTORE_COSTS_ENABLED';\r\nconst logger = new LoggerBase('ðŸ’¸firestore-costs:', LOGGER_ENABLEDKEY);\r\n\r\nconst KEY_SINGLE = 'firecosts-single-reads';\r\n\r\nexport interface IFirestoreLogger {\r\n  logDocument: (count: number) => Function;\r\n  SetEnabled: (isEnabled: boolean) => void;\r\n  ResetCount: (shouldReset: boolean) => void;\r\n}\r\n\r\nexport function MakeFirestoreLogger(\r\n  options: RAFirebaseOptions\r\n): IFirestoreLogger {\r\n  function notEnabled() {\r\n    return !options?.lazyLoading?.enabled;\r\n  }\r\n\r\n  function incrementRead(incrementBy = 1) {\r\n    const currentCountRaw = localStorage.getItem(KEY_SINGLE) || '';\r\n    const currentCount = parseInt(currentCountRaw) || 0;\r\n    const incremented = currentCount + incrementBy;\r\n    localStorage.setItem(KEY_SINGLE, incremented + '');\r\n    return incremented;\r\n  }\r\n  function clearCache() {\r\n    localStorage.removeItem(KEY_SINGLE);\r\n  }\r\n  return {\r\n    SetEnabled(isEnabled: boolean) {\r\n      logger.SetEnabled(isEnabled);\r\n    },\r\n    ResetCount(shouldReset: boolean) {\r\n      shouldReset && clearCache();\r\n    },\r\n    logDocument(docCount: number) {\r\n      if (notEnabled()) {\r\n        return LogNoOp;\r\n      }\r\n      const count = incrementRead(docCount);\r\n      const suffix = `+${docCount} (session total=${count} documents read)`;\r\n      const boundLogFn: (...args: any) => void = logger.log.bind(\r\n        console,\r\n        suffix\r\n      );\r\n      return boundLogFn;\r\n    },\r\n  };\r\n}\r\n","import { LoggerBase } from './logger-base';\r\n\r\nconst LOGGER_ENABLEDKEY = 'LOGGING_ENABLED';\r\nexport const logger = new LoggerBase('ðŸ”¥raf:', LOGGER_ENABLEDKEY);\r\n\r\nexport const log = logger.log;\r\nexport const logError = logger.error;\r\nexport const logWarn = logger.warn;\r\n","import { log } from './logger';\r\n\r\nexport type DispatchEvent =\r\n  | 'FILE_UPLOAD_WILL_START'\r\n  | 'FILE_UPLOAD_PROGRESS'\r\n  | 'FILE_UPLOAD_PAUSED'\r\n  | 'FILE_UPLOAD_RUNNING'\r\n  | 'FILE_UPLOAD_CANCELED'\r\n  | 'FILE_UPLOAD_COMPLETE'\r\n  | 'FILE_SAVED';\r\n\r\nexport function dispatch(\r\n  eventName: DispatchEvent,\r\n  fileName: string,\r\n  data?: any\r\n): void {\r\n  const eventMonitor = document.getElementById('eventMonitor');\r\n  if (!eventMonitor) {\r\n    log(\r\n      `eventMonitor not found to dispatch event ${eventName} for ${fileName}`\r\n    );\r\n    return;\r\n  }\r\n  const eventData = { fileName, data };\r\n  let event = new CustomEvent(eventName, { detail: eventData });\r\n  eventMonitor.dispatchEvent(event);\r\n}\r\n","export const REF_INDENTIFIER = '___REF_FULLPATH_';\r\n\r\nexport interface ParsedRefDoc {\r\n  ___refpath: string;\r\n  ___refid: string;\r\n}\r\n","import { getDownloadURL, ref } from 'firebase/storage';\r\nimport { has, set } from 'lodash';\r\nimport { IFirebaseWrapper } from 'providers/database';\r\nimport { FireStoreDocumentRef } from './firebase-models';\r\nimport { REF_INDENTIFIER } from './internal.models';\r\nimport { logError } from './logger';\r\n\r\nexport interface RefDocFound {\r\n  fieldPath: string;\r\n  refDocPath: string;\r\n}\r\n\r\nexport interface FromFirestoreResult {\r\n  parsedDoc: any;\r\n  refdocs: RefDocFound[];\r\n}\r\n\r\nexport function translateDocFromFirestore(obj: any) {\r\n  const isObject = !!obj && typeof obj === 'object';\r\n  const result: FromFirestoreResult = {\r\n    parsedDoc: {},\r\n    refdocs: [],\r\n  };\r\n  if (!isObject) {\r\n    return result;\r\n  }\r\n  Object.keys(obj).map((key) => {\r\n    const value = obj[key];\r\n    obj[key] = recusivelyCheckObjectValue(value, key, result);\r\n  });\r\n  result.parsedDoc = obj;\r\n  return result;\r\n}\r\n\r\nexport function recusivelyCheckObjectValue(\r\n  input: any,\r\n  fieldPath: string,\r\n  result: FromFirestoreResult\r\n): any {\r\n  const isFalsey = !input;\r\n  if (isFalsey) {\r\n    return input;\r\n  }\r\n  const isPrimitive = typeof input !== 'object';\r\n  if (isPrimitive) {\r\n    return input;\r\n  }\r\n  const isTimestamp = !!input.toDate && typeof input.toDate === 'function';\r\n  if (isTimestamp) {\r\n    return input.toDate();\r\n  }\r\n  const isArray = Array.isArray(input);\r\n  if (isArray) {\r\n    return (input as any[]).map((value, index) =>\r\n      recusivelyCheckObjectValue(value, `${fieldPath}.${index}`, result)\r\n    );\r\n  }\r\n  const isDocumentReference = isInputADocReference(input);\r\n  if (isDocumentReference) {\r\n    const documentReference = input as FireStoreDocumentRef;\r\n    result.refdocs.push({\r\n      fieldPath: fieldPath,\r\n      refDocPath: documentReference.path,\r\n    });\r\n    return documentReference.id;\r\n  }\r\n  const isObject = typeof input === 'object';\r\n  if (isObject) {\r\n    Object.keys(input).map((key) => {\r\n      const value = input[key];\r\n      input[key] = recusivelyCheckObjectValue(value, key, result);\r\n    });\r\n    return input;\r\n  }\r\n  return input;\r\n}\r\n\r\nfunction isInputADocReference(input: any): boolean {\r\n  const isDocumentReference =\r\n    typeof input.id === 'string' &&\r\n    typeof input.firestore === 'object' &&\r\n    typeof input.parent === 'object' &&\r\n    typeof input.path === 'string';\r\n  return isDocumentReference;\r\n}\r\n\r\nexport function applyRefDocs(doc: any, refDocs: RefDocFound[]) {\r\n  refDocs.map((d) => {\r\n    set(doc, REF_INDENTIFIER + d.fieldPath, d.refDocPath);\r\n  });\r\n  return doc;\r\n}\r\n\r\nexport const recursivelyMapStorageUrls = async (\r\n  fireWrapper: IFirebaseWrapper,\r\n  fieldValue: any\r\n): Promise<any> => {\r\n  const isPrimitive = !fieldValue || typeof fieldValue !== 'object';\r\n  if (isPrimitive) {\r\n    return fieldValue;\r\n  }\r\n  const isFileField = has(fieldValue, 'src');\r\n  if (isFileField) {\r\n    try {\r\n      const src = await getDownloadURL(\r\n        ref(fireWrapper.storage(), fieldValue.src)\r\n      );\r\n      return {\r\n        ...fieldValue,\r\n        src,\r\n      };\r\n    } catch (error) {\r\n      logError(`Error when getting download URL`, {\r\n        error,\r\n      });\r\n      return fieldValue;\r\n    }\r\n  }\r\n  const isArray = Array.isArray(fieldValue);\r\n  if (isArray) {\r\n    return Promise.all(\r\n      (fieldValue as any[]).map(async (value, index) => {\r\n        fieldValue[index] = await recursivelyMapStorageUrls(fireWrapper, value);\r\n      })\r\n    );\r\n  }\r\n  const isDocumentReference = isInputADocReference(fieldValue);\r\n  if (isDocumentReference) {\r\n    return fieldValue;\r\n  }\r\n  const isObject = !isArray && typeof fieldValue === 'object';\r\n  if (isObject) {\r\n    return Promise.all(\r\n      Object.keys(fieldValue).map(async (key) => {\r\n        const value = fieldValue[key];\r\n        fieldValue[key] = await recursivelyMapStorageUrls(fireWrapper, value);\r\n      })\r\n    );\r\n  }\r\n};\r\n","import {\r\n  FireStoreDocumentSnapshot,\r\n  FireStoreQueryDocumentSnapshot,\r\n} from './firebase-models';\r\nimport { logWarn } from './logger';\r\nimport * as ra from './react-admin-models';\r\nimport {\r\n  applyRefDocs,\r\n  translateDocFromFirestore,\r\n} from './translate-from-firestore';\r\n\r\nexport function parseFireStoreDocument<T extends ra.Record>(\r\n  doc: FireStoreQueryDocumentSnapshot | FireStoreDocumentSnapshot | undefined\r\n): T {\r\n  if (!doc) {\r\n    logWarn('parseFireStoreDocument: no doc', { doc });\r\n    return {} as T;\r\n  }\r\n  const data = doc.data();\r\n  const result = translateDocFromFirestore(data);\r\n  const dataWithRefs = applyRefDocs(result.parsedDoc, result.refdocs);\r\n  // React Admin requires an id field on every document,\r\n  // So we can just use the firestore document id\r\n  return { id: doc.id, ...dataWithRefs } as T;\r\n}\r\n","import path from 'path-browserify';\r\n\r\nexport function getAbsolutePath(\r\n  rootRef: undefined | string | (() => string),\r\n  relativePath: string | null\r\n): string {\r\n  if (!rootRef) {\r\n    return relativePath + '';\r\n  }\r\n  if (!relativePath) {\r\n    throw new Error(\r\n      'Resource name must be a string of length greater than 0 characters'\r\n    );\r\n  }\r\n  const rootRefValue = typeof rootRef === 'string' ? rootRef : rootRef();\r\n  const withSlashes = path.join('/', rootRefValue, '/', relativePath, '/');\r\n  const slashCount = withSlashes.split('/').length - 1;\r\n  if (slashCount % 2) {\r\n    throw new Error(`The rootRef path must point to a \"document\"\r\n    not a \"collection\"e.g. /collection/document/ or\r\n    /collection/document/collection/document/`);\r\n  }\r\n  return withSlashes.slice(1, -1);\r\n}\r\n\r\nexport function joinPaths(...args: string[]) {\r\n  return path.join(...args);\r\n}\r\n","import { REF_INDENTIFIER } from './internal.models';\r\n\r\ninterface ParsedUpload {\r\n  fieldDotsPath: string;\r\n  fieldSlashesPath: string;\r\n  rawFile: File | any;\r\n}\r\n\r\ninterface ParsedDocRef {\r\n  fieldDotsPath: string;\r\n  refPath: string;\r\n}\r\n\r\ninterface ParseResult {\r\n  parsedDoc: any;\r\n  uploads: ParsedUpload[];\r\n  refdocs: ParsedDocRef[];\r\n}\r\n\r\nexport function translateDocToFirestore(obj: any): ParseResult {\r\n  const isObject = !!obj && typeof obj === 'object';\r\n  const result: ParseResult = {\r\n    uploads: [],\r\n    refdocs: [],\r\n    parsedDoc: {},\r\n  };\r\n  if (!isObject) {\r\n    return result;\r\n  }\r\n  Object.keys(obj).map((key) => {\r\n    const value = obj[key];\r\n    recusivelyParseObjectValue(value, key, result);\r\n  });\r\n  result.parsedDoc = obj;\r\n  return result;\r\n}\r\n\r\nexport function recusivelyParseObjectValue(\r\n  input: any,\r\n  fieldPath: string,\r\n  result: ParseResult\r\n): any {\r\n  const isFalsey = !input;\r\n  if (isFalsey) {\r\n    return input;\r\n  }\r\n  const isRefField =\r\n    typeof fieldPath === 'string' && fieldPath.includes(REF_INDENTIFIER);\r\n  if (isRefField) {\r\n    const refDocFullPath = input as string;\r\n    result.refdocs.push({\r\n      fieldDotsPath: fieldPath,\r\n      refPath: refDocFullPath,\r\n    });\r\n    return;\r\n  }\r\n  const isPrimitive = typeof input !== 'object';\r\n  if (isPrimitive) {\r\n    return input;\r\n  }\r\n  const isTimestamp = !!input.toDate && typeof input.toDate === 'function';\r\n  if (isTimestamp) {\r\n    return input.toDate();\r\n  }\r\n  const isArray = Array.isArray(input);\r\n  if (isArray) {\r\n    return (input as []).map((value, index) =>\r\n      recusivelyParseObjectValue(value, `${fieldPath}.${index}`, result)\r\n    );\r\n  }\r\n  const isFileField = !!input && input.hasOwnProperty('rawFile');\r\n  if (isFileField) {\r\n    result.uploads.push({\r\n      fieldDotsPath: fieldPath,\r\n      fieldSlashesPath: fieldPath.split('.').join('/'),\r\n      rawFile: input.rawFile,\r\n    });\r\n    delete input.rawFile;\r\n    return;\r\n  }\r\n  Object.keys(input).map((key) => {\r\n    const value = input[key];\r\n    recusivelyParseObjectValue(value, `${fieldPath}.${key}`, result);\r\n  });\r\n  return input;\r\n}\r\n","import { FirebaseApp, getApp, getApps, initializeApp } from 'firebase/app';\r\nimport {\r\n  browserLocalPersistence,\r\n  browserSessionPersistence,\r\n  getAuth,\r\n  inMemoryPersistence,\r\n  onAuthStateChanged,\r\n  Persistence,\r\n  signInWithEmailAndPassword,\r\n  signOut,\r\n} from 'firebase/auth';\r\nimport {\r\n  collection,\r\n  doc,\r\n  getFirestore,\r\n  serverTimestamp as firestoreServerTimestamp,\r\n  writeBatch,\r\n} from 'firebase/firestore';\r\nimport {\r\n  getDownloadURL,\r\n  getStorage,\r\n  ref,\r\n  uploadBytesResumable,\r\n} from 'firebase/storage';\r\nimport {\r\n  FireApp,\r\n  FireAuth,\r\n  FireAuthUserCredentials,\r\n  FireStorage,\r\n  FireStoragePutFileResult,\r\n  FireStore,\r\n  FireStoreBatch,\r\n  FireStoreCollectionRef,\r\n  FireUploadTaskSnapshot,\r\n  FireUser,\r\n} from 'misc/firebase-models';\r\nimport { log } from '../../../misc';\r\nimport { RAFirebaseOptions } from '../../options';\r\nimport { IFirebaseWrapper } from './IFirebaseWrapper';\r\n\r\nexport class FirebaseWrapper implements IFirebaseWrapper {\r\n  private readonly _app: FireApp;\r\n  private readonly _firestore: FireStore;\r\n  private readonly _storage: FireStorage;\r\n  private readonly _auth: FireAuth;\r\n  public options: RAFirebaseOptions;\r\n\r\n  constructor(inputOptions: RAFirebaseOptions | undefined, firebaseConfig: {}) {\r\n    const optionsSafe = inputOptions || {};\r\n    this.options = optionsSafe;\r\n    this._app = (window as any)['_app'] = ObtainFirebaseApp(\r\n      firebaseConfig,\r\n      optionsSafe\r\n    );\r\n    this._firestore = getFirestore(this._app);\r\n    this._storage = getStorage(this._app);\r\n    this._auth = getAuth(this._app);\r\n  }\r\n  dbGetCollection(absolutePath: string): FireStoreCollectionRef {\r\n    return collection(this._firestore, absolutePath);\r\n  }\r\n  dbCreateBatch(): FireStoreBatch {\r\n    return writeBatch(this._firestore);\r\n  }\r\n  dbMakeNewId(): string {\r\n    return doc(collection(this._firestore, 'collections')).id;\r\n  }\r\n\r\n  public OnUserLogout(callBack: (u: FireUser | null) => any) {\r\n    this._auth.onAuthStateChanged((user) => {\r\n      const isLoggedOut = !user;\r\n      log('FirebaseWrapper.OnUserLogout', { user, isLoggedOut });\r\n      if (isLoggedOut) {\r\n        callBack(user);\r\n      }\r\n    });\r\n  }\r\n  putFile(storagePath: string, rawFile: any): FireStoragePutFileResult {\r\n    const task = uploadBytesResumable(ref(this._storage, storagePath), rawFile);\r\n    const taskResult = new Promise<FireUploadTaskSnapshot>((res, rej) =>\r\n      task.then(res).catch(rej)\r\n    );\r\n\r\n    const downloadUrl = taskResult\r\n      .then((t) => getDownloadURL(t.ref))\r\n      .then((url) => url as string);\r\n\r\n    return {\r\n      task,\r\n      taskResult,\r\n      downloadUrl,\r\n    };\r\n  }\r\n  async getStorageDownloadUrl(fieldSrc: string): Promise<string> {\r\n    return getDownloadURL(ref(this._storage, fieldSrc));\r\n  }\r\n  public serverTimestamp() {\r\n    // This line doesn't work for some reason, might be firebase sdk.\r\n    return firestoreServerTimestamp();\r\n  }\r\n\r\n  async authSetPersistence(persistenceInput: 'session' | 'local' | 'none') {\r\n    let persistenceResolved: Persistence;\r\n    switch (persistenceInput) {\r\n      case 'local':\r\n        persistenceResolved = browserLocalPersistence;\r\n        break;\r\n      case 'none':\r\n        persistenceResolved = inMemoryPersistence;\r\n        break;\r\n      case 'session':\r\n      default:\r\n        persistenceResolved = browserSessionPersistence;\r\n        break;\r\n    }\r\n\r\n    log('setPersistence', { persistenceInput, persistenceResolved });\r\n\r\n    return this._auth\r\n      .setPersistence(persistenceResolved)\r\n      .catch((error) => console.error(error));\r\n  }\r\n  async authSigninEmailPassword(\r\n    email: string,\r\n    password: string\r\n  ): Promise<FireAuthUserCredentials> {\r\n    const user = await signInWithEmailAndPassword(this._auth, email, password);\r\n    return user;\r\n  }\r\n  async authSignOut(): Promise<void> {\r\n    return signOut(this._auth);\r\n  }\r\n  async authGetUserLoggedIn(): Promise<FireUser> {\r\n    return new Promise((resolve, reject) => {\r\n      const auth = this._auth;\r\n      if (auth.currentUser) return resolve(auth.currentUser);\r\n      const unsubscribe = onAuthStateChanged(this._auth, (user) => {\r\n        unsubscribe();\r\n        if (user) {\r\n          resolve(user);\r\n        } else {\r\n          reject();\r\n        }\r\n      });\r\n    });\r\n  }\r\n  public async GetUserLogin(): Promise<FireUser> {\r\n    return this.authGetUserLoggedIn();\r\n  }\r\n\r\n  /** @deprecated */\r\n  public auth(): FireAuth {\r\n    return this._auth;\r\n  }\r\n  /** @deprecated */\r\n  public storage(): FireStorage {\r\n    return this._storage;\r\n  }\r\n  /** @deprecated */\r\n  public GetApp(): FireApp {\r\n    return this._app;\r\n  }\r\n  /** @deprecated */\r\n  public db(): FireStore {\r\n    return this._firestore;\r\n  }\r\n}\r\n\r\nfunction ObtainFirebaseApp(\r\n  firebaseConfig: {},\r\n  options: RAFirebaseOptions\r\n): FirebaseApp {\r\n  if (options.app) {\r\n    return options.app;\r\n  }\r\n  const apps = getApps();\r\n\r\n  const isInitialized = !!apps?.length;\r\n\r\n  if (isInitialized) {\r\n    return getApp();\r\n  } else {\r\n    return initializeApp(firebaseConfig);\r\n  }\r\n}\r\n","import { log, logger, logWarn, retrieveStatusTxt } from '../misc';\r\nimport { FireUser } from '../misc/firebase-models';\r\nimport {\r\n  AuthProvider as RaAuthProvider,\r\n  UserIdentity,\r\n} from '../misc/react-admin-models';\r\nimport { messageTypes } from './../misc/messageTypes';\r\nimport { IFirebaseWrapper } from './database';\r\nimport { FirebaseWrapper } from './database/firebase/FirebaseWrapper';\r\nimport { RAFirebaseOptions } from './options';\r\n\r\nclass AuthClient {\r\n  private fireWrapper: IFirebaseWrapper;\r\n\r\n  constructor(firebaseConfig: {}, optionsInput?: RAFirebaseOptions) {\r\n    const options = optionsInput || {};\r\n    log('Auth Client: initializing...', { firebaseConfig, options });\r\n    this.fireWrapper = new FirebaseWrapper(options, firebaseConfig);\r\n    options.persistence && this.setPersistence(options.persistence);\r\n  }\r\n\r\n  setPersistence(persistenceInput: 'session' | 'local' | 'none') {\r\n    return this.fireWrapper.authSetPersistence(persistenceInput);\r\n  }\r\n\r\n  public async HandleAuthLogin(params: { username: string; password: string }) {\r\n    const { username, password } = params;\r\n\r\n    if (username && password) {\r\n      try {\r\n        const user = await this.fireWrapper.authSigninEmailPassword(\r\n          username,\r\n          password\r\n        );\r\n        log('HandleAuthLogin: user sucessfully logged in', { user });\r\n        return user;\r\n      } catch (e) {\r\n        log('HandleAuthLogin: invalid credentials', { params });\r\n        throw new Error('Login error: invalid credentials');\r\n      }\r\n    } else {\r\n      return this.getUserLogin();\r\n    }\r\n  }\r\n\r\n  public HandleAuthLogout() {\r\n    return this.fireWrapper.authSignOut();\r\n  }\r\n\r\n  public HandleAuthError(errorHttp: messageTypes.HttpErrorType) {\r\n    log('HandleAuthLogin: invalid credentials', { errorHttp });\r\n    const status = !!errorHttp && errorHttp.status;\r\n    const statusTxt = retrieveStatusTxt(status);\r\n    if (statusTxt === 'ok') {\r\n      log('API is actually authenticated');\r\n      return Promise.resolve();\r\n    }\r\n    logWarn('Received authentication error from API');\r\n    return Promise.reject();\r\n  }\r\n\r\n  public async HandleAuthCheck(): Promise<any> {\r\n    return this.getUserLogin();\r\n  }\r\n\r\n  public getUserLogin(): Promise<FireUser> {\r\n    return this.fireWrapper.authGetUserLoggedIn();\r\n  }\r\n\r\n  public async HandleGetPermissions() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.claims;\r\n    } catch (e) {\r\n      log('HandleGetPermission: no user is logged in or tokenResult error', {\r\n        e,\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetIdentity(): Promise<UserIdentity> {\r\n    try {\r\n      const { uid, displayName, photoURL } = await this.getUserLogin();\r\n      const identity: UserIdentity = {\r\n        id: uid,\r\n        fullName: `${displayName ?? ''}`,\r\n        avatar: `${photoURL ?? ''}`,\r\n      };\r\n      return identity;\r\n    } catch (e) {\r\n      log('HandleGetIdentity: no user is logged in', {\r\n        e,\r\n      });\r\n      return null as any;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTAuthTime() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.authTime;\r\n    } catch (e) {\r\n      log('HandleGetJWTAuthTime: no user is logged in or tokenResult error', {\r\n        e,\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTExpirationTime() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.expirationTime;\r\n    } catch (e) {\r\n      log(\r\n        'HandleGetJWTExpirationTime: no user is logged in or tokenResult error',\r\n        {\r\n          e,\r\n        }\r\n      );\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTSignInProvider() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.signInProvider;\r\n    } catch (e) {\r\n      log(\r\n        'HandleGetJWTSignInProvider: no user is logged in or tokenResult error',\r\n        {\r\n          e,\r\n        }\r\n      );\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTIssuedAtTime() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.issuedAtTime;\r\n    } catch (e) {\r\n      log(\r\n        'HandleGetJWTIssuedAtTime: no user is logged in or tokenResult error',\r\n        {\r\n          e,\r\n        }\r\n      );\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTToken() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.token;\r\n    } catch (e) {\r\n      log('HandleGetJWTToken: no user is logged in or tokenResult error', {\r\n        e,\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\nexport function AuthProvider(\r\n  firebaseConfig: {},\r\n  options: RAFirebaseOptions\r\n): ReactAdminFirebaseAuthProvider {\r\n  VerifyAuthProviderArgs(firebaseConfig, options);\r\n  logger.SetEnabled(!!options?.logging);\r\n  const auth = new AuthClient(firebaseConfig, options);\r\n\r\n  const provider: ReactAdminFirebaseAuthProvider = {\r\n    // React Admin Interface\r\n    login: (params) => auth.HandleAuthLogin(params),\r\n    logout: () => auth.HandleAuthLogout(),\r\n    checkAuth: () => auth.HandleAuthCheck(),\r\n    checkError: (error) => auth.HandleAuthError(error),\r\n    getPermissions: () => auth.HandleGetPermissions(),\r\n    getIdentity: () => auth.HandleGetIdentity(),\r\n    // Custom Functions\r\n    getAuthUser: () => auth.getUserLogin(),\r\n    getJWTAuthTime: () => auth.HandleGetJWTAuthTime(),\r\n    getJWTExpirationTime: () => auth.HandleGetJWTExpirationTime(),\r\n    getJWTSignInProvider: () => auth.HandleGetJWTSignInProvider(),\r\n    getJWTClaims: () => auth.HandleGetPermissions(),\r\n    getJWTToken: () => auth.HandleGetJWTToken(),\r\n  };\r\n  return provider;\r\n}\r\n\r\nexport type ReactAdminFirebaseAuthProvider = RaAuthProvider & {\r\n  // Custom Functions\r\n  getAuthUser: () => Promise<FireUser>;\r\n  getJWTAuthTime: () => Promise<string | null>;\r\n  getJWTExpirationTime: () => Promise<string | null>;\r\n  getJWTSignInProvider: () => Promise<string | null>;\r\n  getJWTClaims: () => Promise<{ [key: string]: any } | null>;\r\n  getJWTToken: () => Promise<string | null>;\r\n};\r\n\r\nfunction VerifyAuthProviderArgs(\r\n  firebaseConfig: {},\r\n  options: RAFirebaseOptions\r\n) {\r\n  const hasNoApp = !options || !options.app;\r\n  const hasNoConfig = !firebaseConfig;\r\n  if (hasNoConfig && hasNoApp) {\r\n    throw new Error(\r\n      'Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider'\r\n    );\r\n  }\r\n}\r\n","// From firebase SDK\r\n\r\nimport { logError } from './logger';\r\n\r\n// tslint:disable-next-line:max-line-length\r\n// - https://github.com/firebase/firebase-js-sdk/blob/9f109f85ad0d99f6c13e68dcb549a0b852e35a2a/packages/functions/src/api/error.ts\r\nexport function retrieveStatusTxt(status: number): 'ok' | 'unauthenticated' {\r\n  // Make sure any successful status is OK.\r\n  if (status >= 200 && status < 300) {\r\n    return 'ok';\r\n  }\r\n  switch (status) {\r\n    case 401: // 'unauthenticated'\r\n    case 403: // 'permission-denied'\r\n      return 'unauthenticated';\r\n\r\n    case 0: // 'internal'\r\n    case 400: // 'invalid-argument'\r\n    case 404: // 'not-found'\r\n    case 409: // 'aborted'\r\n    case 429: // 'resource-exhausted'\r\n    case 499: // 'cancelled'\r\n    case 500: // 'internal'\r\n    case 501: // 'unimplemented'\r\n    case 503: // 'unavailable'\r\n    case 504: // 'deadline-exceeded'\r\n    default:\r\n      // ignore\r\n      return 'ok';\r\n  }\r\n}\r\n\r\n// From firebase SDK\r\n// tslint:disable-next-line:max-line-length\r\n// - https://github.com/firebase/firebase-js-sdk/blob/9f109f85ad0d99f6c13e68dcb549a0b852e35a2a/packages/functions/src/api/error.ts\r\nexport function retrieveStatusCode(statusTxt: string): number {\r\n  // Make sure any successful status is OK.\r\n  const regexResult = /\\[code\\=([\\w-]*)/g.exec(statusTxt);\r\n  const status = Array.isArray(regexResult) && regexResult[1];\r\n  if (!status) {\r\n    logError('unknown StatusCode ', { statusTxt });\r\n  }\r\n  switch (status) {\r\n    case 'unauthenticated':\r\n      return 401;\r\n    case 'permission-denied':\r\n      return 403;\r\n    case 'internal':\r\n      return 0;\r\n    case 'invalid-argument':\r\n      return 400;\r\n    case 'not-found':\r\n      return 404;\r\n    case 'aborted':\r\n      return 409;\r\n    case 'resource-exhausted':\r\n      return 429;\r\n    case 'cancelled':\r\n      return 499;\r\n    case 'internal':\r\n      return 500;\r\n    case 'unimplemented':\r\n      return 501;\r\n    case 'unavailable':\r\n      return 503;\r\n    case 'deadline-exceeded':\r\n      return 504;\r\n    default:\r\n      return 200;\r\n  }\r\n}\r\n","import { doc, getDoc, getDocs } from 'firebase/firestore';\r\nimport { FireStoreCollectionRef, FireStoreQuery } from 'misc/firebase-models';\r\nimport {\r\n  getAbsolutePath,\r\n  IFirestoreLogger,\r\n  log,\r\n  logWarn,\r\n  messageTypes,\r\n  parseFireStoreDocument,\r\n} from '../../misc';\r\nimport { RAFirebaseOptions } from '../options';\r\nimport { IFirebaseWrapper } from './firebase/IFirebaseWrapper';\r\n\r\ntype IResourceItem = {} & { id: string; deleted?: boolean };\r\nexport interface IResource {\r\n  path: string;\r\n  pathAbsolute: string;\r\n  collection: FireStoreCollectionRef;\r\n  list: Array<IResourceItem>;\r\n}\r\n\r\nexport class ResourceManager {\r\n  private resources: Record<string, IResource> = {};\r\n\r\n  constructor(\r\n    private fireWrapper: IFirebaseWrapper,\r\n    private options: RAFirebaseOptions,\r\n    private flogger: IFirestoreLogger\r\n  ) {\r\n    this.fireWrapper.OnUserLogout(() => {\r\n      this.resources = {};\r\n    });\r\n  }\r\n\r\n  public async TryGetResource(\r\n    resourceName: string,\r\n    refresh?: 'REFRESH',\r\n    collectionQuery?: messageTypes.CollectionQueryType\r\n  ): Promise<IResource> {\r\n    if (refresh) {\r\n      await this.RefreshResource(resourceName, collectionQuery);\r\n    }\r\n    return this.TryGetResourcePromise(resourceName, collectionQuery);\r\n  }\r\n\r\n  public GetResource(relativePath: string): IResource {\r\n    const resource: IResource = this.resources[relativePath];\r\n    if (!resource) {\r\n      throw new Error(\r\n        `react-admin-firebase: Can't find resource: \"${relativePath}\"`\r\n      );\r\n    }\r\n    return resource;\r\n  }\r\n\r\n  public async TryGetResourcePromise(\r\n    relativePath: string,\r\n    collectionQuery?: messageTypes.CollectionQueryType\r\n  ): Promise<IResource> {\r\n    log('resourceManager.TryGetResourcePromise', {\r\n      relativePath,\r\n      collectionQuery,\r\n    });\r\n    await this.initPath(relativePath);\r\n\r\n    const resource: IResource = this.resources[relativePath];\r\n    if (!resource) {\r\n      throw new Error(\r\n        `react-admin-firebase: Cant find resource: \"${relativePath}\"`\r\n      );\r\n    }\r\n    return resource;\r\n  }\r\n\r\n  public async RefreshResource(\r\n    relativePath: string,\r\n    collectionQuery: messageTypes.CollectionQueryType | undefined\r\n  ) {\r\n    if (this.options?.lazyLoading?.enabled) {\r\n      logWarn('resourceManager.RefreshResource', {\r\n        warn: 'RefreshResource is not available in lazy loading mode',\r\n      });\r\n      throw new Error(\r\n        'react-admin-firebase: RefreshResource is not available in lazy loading mode'\r\n      );\r\n    }\r\n\r\n    log('resourceManager.RefreshResource', { relativePath, collectionQuery });\r\n    await this.initPath(relativePath);\r\n    const resource = this.resources[relativePath];\r\n\r\n    const collectionRef = resource.collection;\r\n    const collectionOrQuery = this.applyQuery(collectionRef, collectionQuery);\r\n    const newDocs = await getDocs(collectionOrQuery);\r\n\r\n    newDocs.forEach((d) =>\r\n      resource.list.push(parseFireStoreDocument<IResourceItem>(d))\r\n    );\r\n\r\n    const count = newDocs.docs.length;\r\n    this.flogger.logDocument(count)();\r\n    log('resourceManager.RefreshResource', {\r\n      newDocs,\r\n      resource,\r\n      collectionPath: collectionRef.path,\r\n    });\r\n  }\r\n\r\n  public async GetSingleDoc(relativePath: string, docId: string) {\r\n    await this.initPath(relativePath);\r\n    const resource = this.GetResource(relativePath);\r\n    this.flogger.logDocument(1)();\r\n    const docSnap = await getDoc(doc(resource.collection, docId));\r\n    if (!docSnap.exists) {\r\n      throw new Error('react-admin-firebase: No id found matching: ' + docId);\r\n    }\r\n    const result = parseFireStoreDocument(docSnap);\r\n    log('resourceManager.GetSingleDoc', {\r\n      relativePath,\r\n      resource,\r\n      docId,\r\n      docSnap,\r\n      result,\r\n    });\r\n    return result;\r\n  }\r\n\r\n  private async initPath(relativePath: string): Promise<void> {\r\n    const rootRef = this.options && this.options.rootRef;\r\n    const absolutePath = getAbsolutePath(rootRef, relativePath);\r\n    const hasBeenInited = !!this.resources[relativePath];\r\n    log('resourceManager.initPath()', {\r\n      absolutePath,\r\n      hasBeenInited,\r\n    });\r\n    if (hasBeenInited) {\r\n      log('resourceManager.initPath() has been initialized already...');\r\n      return;\r\n    }\r\n    const collection = this.fireWrapper.dbGetCollection(absolutePath);\r\n    const list: Array<IResourceItem> = [];\r\n    const resource: IResource = {\r\n      collection,\r\n      list,\r\n      path: relativePath,\r\n      pathAbsolute: absolutePath,\r\n    };\r\n    this.resources[relativePath] = resource;\r\n    log('resourceManager.initPath() setting resource...', {\r\n      resource,\r\n      allResources: this.resources,\r\n      collection: collection,\r\n      collectionPath: collection.path,\r\n    });\r\n  }\r\n\r\n  public async getUserIdentifier(): Promise<string> {\r\n    const identifier = this.options.associateUsersById\r\n      ? await this.getCurrentUserId()\r\n      : await this.getCurrentUserEmail();\r\n    return identifier;\r\n  }\r\n\r\n  private async getCurrentUserEmail() {\r\n    const user = await this.fireWrapper.authGetUserLoggedIn();\r\n    if (user) {\r\n      return user.email as string;\r\n    } else {\r\n      return 'annonymous user';\r\n    }\r\n  }\r\n  private async getCurrentUserId() {\r\n    const user = await this.fireWrapper.authGetUserLoggedIn();\r\n    if (user) {\r\n      return user.uid;\r\n    } else {\r\n      return 'annonymous user';\r\n    }\r\n  }\r\n\r\n  private applyQuery(\r\n    collection: FireStoreCollectionRef,\r\n    collectionQuery?: messageTypes.CollectionQueryType\r\n  ): FireStoreCollectionRef | FireStoreQuery {\r\n    const collRef = collectionQuery ? collectionQuery(collection) : collection;\r\n\r\n    log('resourceManager.applyQuery() ...', {\r\n      collection,\r\n      collectionQuery: (collectionQuery || '-').toString(),\r\n      collRef,\r\n    });\r\n    return collRef;\r\n  }\r\n}\r\n","import { doc } from 'firebase/firestore';\r\nimport { get, set } from 'lodash';\r\nimport {\r\n  AddCreatedByFields,\r\n  AddUpdatedByFields,\r\n  dispatch,\r\n  IFirestoreLogger,\r\n  log,\r\n  logError,\r\n  parseStoragePath,\r\n  translateDocToFirestore,\r\n} from '../../misc';\r\nimport {\r\n  TASK_CANCELED,\r\n  TASK_PAUSED,\r\n  TASK_RUNNING,\r\n} from '../../misc/firebase-models';\r\nimport { RAFirebaseOptions } from '../options';\r\nimport { IFirebaseWrapper } from './firebase/IFirebaseWrapper';\r\nimport { IResource, ResourceManager } from './ResourceManager';\r\n\r\nexport class FireClient {\r\n  public rm: ResourceManager;\r\n\r\n  constructor(\r\n    public fireWrapper: IFirebaseWrapper,\r\n    public options: RAFirebaseOptions,\r\n    public flogger: IFirestoreLogger\r\n  ) {\r\n    this.rm = new ResourceManager(this.fireWrapper, this.options, this.flogger);\r\n  }\r\n\r\n  public checkRemoveIdField(obj: any, docId: string) {\r\n    if (!this.options.dontAddIdFieldToDoc) {\r\n      obj.id = docId;\r\n    }\r\n  }\r\n\r\n  public transformToDb(\r\n    resourceName: string,\r\n    documentData: any,\r\n    docId: string\r\n  ): any {\r\n    if (typeof this.options.transformToDb === 'function') {\r\n      return this.options.transformToDb(resourceName, documentData, docId);\r\n    }\r\n    return documentData;\r\n  }\r\n\r\n  public async parseDataAndUpload(r: IResource, id: string, data: any) {\r\n    if (!data) {\r\n      return data;\r\n    }\r\n    const docPath = doc(r.collection, id).path;\r\n\r\n    const result = translateDocToFirestore(data);\r\n    const uploads = result.uploads;\r\n    await Promise.all(\r\n      uploads.map(async (u) => {\r\n        const storagePath = parseStoragePath(\r\n          u.rawFile,\r\n          docPath,\r\n          u.fieldDotsPath,\r\n          !!this.options.useFileNamesInStorage\r\n        );\r\n        const link = await this.saveFile(storagePath, u.rawFile);\r\n        set(data, u.fieldDotsPath + '.src', link);\r\n      })\r\n    );\r\n    return data;\r\n  }\r\n\r\n  public async addCreatedByFields(obj: any) {\r\n    return AddCreatedByFields(obj, this.fireWrapper, this.rm, this.options);\r\n  }\r\n\r\n  public async addUpdatedByFields(obj: any) {\r\n    return AddUpdatedByFields(obj, this.fireWrapper, this.rm, this.options);\r\n  }\r\n\r\n  private async saveFile(\r\n    storagePath: string,\r\n    rawFile: any\r\n  ): Promise<string | undefined> {\r\n    log('saveFile() saving file...', { storagePath, rawFile });\r\n    try {\r\n      const { task, taskResult, downloadUrl } = this.fireWrapper.putFile(\r\n        storagePath,\r\n        rawFile\r\n      );\r\n      const { name } = rawFile;\r\n      // monitor upload status & progress\r\n      dispatch('FILE_UPLOAD_WILL_START', name);\r\n      task.on('state_changed', (snapshot) => {\r\n        const progress =\r\n          (snapshot.bytesTransferred / snapshot.totalBytes) * 100;\r\n        log('Upload is ' + progress + '% done');\r\n        dispatch('FILE_UPLOAD_PROGRESS', name, progress);\r\n        switch (snapshot.state) {\r\n          case TASK_PAUSED:\r\n            log('Upload is paused');\r\n            dispatch('FILE_UPLOAD_PAUSED', name);\r\n            break;\r\n          case TASK_RUNNING:\r\n            log('Upload is running');\r\n            dispatch('FILE_UPLOAD_RUNNING', name);\r\n            break;\r\n          case TASK_CANCELED:\r\n            log('Upload has been canceled');\r\n            dispatch('FILE_UPLOAD_CANCELED', name);\r\n            break;\r\n          // case storage.TaskState.ERROR:\r\n          // already handled by catch\r\n          // case storage.TaskState.SUCCESS:\r\n          // already handled by then\r\n        }\r\n      });\r\n      const [getDownloadURL] = await Promise.all([downloadUrl, taskResult]);\r\n      dispatch('FILE_UPLOAD_COMPLETE', name);\r\n      dispatch('FILE_SAVED', name);\r\n      log('saveFile() saved file', {\r\n        storagePath,\r\n        taskResult,\r\n        getDownloadURL,\r\n      });\r\n      return this.options.relativeFilePaths ? storagePath : getDownloadURL;\r\n    } catch (storageError) {\r\n      if (get(storageError, 'code') === 'storage/unknown') {\r\n        logError(\r\n          'saveFile() error saving file, No bucket found! Try clicking \"Get Started\" in firebase -> storage',\r\n          { storageError }\r\n        );\r\n      } else {\r\n        logError('saveFile() error saving file', {\r\n          storageError,\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { joinPaths } from './pathHelper';\r\n\r\nexport function parseStoragePath(\r\n  rawFile: File,\r\n  docPath: string,\r\n  fieldPath: string,\r\n  useFileName: boolean\r\n): string {\r\n  const fileNameBits = rawFile instanceof File ? rawFile.name.split('.') : [];\r\n\r\n  const fileExtension = !fileNameBits?.length ? '' : '.' + fileNameBits.pop();\r\n\r\n  return useFileName\r\n    ? joinPaths(docPath, fieldPath, rawFile.name)\r\n    : joinPaths(docPath, fieldPath + fileExtension);\r\n}\r\n","import { RAFirebaseOptions } from 'index';\r\nimport { IFirebaseWrapper, ResourceManager } from 'providers/database';\r\n\r\nexport async function AddCreatedByFields(\r\n  obj: any,\r\n  fireWrapper: IFirebaseWrapper,\r\n  rm: Pick<ResourceManager, 'getUserIdentifier'>,\r\n  options: Pick<\r\n    RAFirebaseOptions,\r\n    | 'associateUsersById'\r\n    | 'disableMeta'\r\n    | 'renameMetaFields'\r\n    | 'metaFieldCasing'\r\n  >\r\n) {\r\n  if (options.disableMeta) {\r\n    return;\r\n  }\r\n  const currentUserIdentifier = await rm.getUserIdentifier();\r\n  const createAtSelector = GetSelectorsCreateAt(options);\r\n  const createBySelector = GetSelectorsCreateBy(options);\r\n  obj[createAtSelector] = fireWrapper.serverTimestamp();\r\n  obj[createBySelector] = currentUserIdentifier;\r\n}\r\n\r\nexport async function AddUpdatedByFields(\r\n  obj: any,\r\n  fireWrapper: IFirebaseWrapper,\r\n  rm: Pick<ResourceManager, 'getUserIdentifier'>,\r\n  options: Pick<\r\n    RAFirebaseOptions,\r\n    | 'associateUsersById'\r\n    | 'disableMeta'\r\n    | 'renameMetaFields'\r\n    | 'metaFieldCasing'\r\n  >\r\n) {\r\n  if (options.disableMeta) {\r\n    return;\r\n  }\r\n  const currentUserIdentifier = await rm.getUserIdentifier();\r\n  const updateAtSelector = GetSelectorsUpdateAt(options);\r\n  const updateBySelector = GetSelectorsUpdateBy(options);\r\n  obj[updateAtSelector] = fireWrapper.serverTimestamp();\r\n  obj[updateBySelector] = currentUserIdentifier;\r\n}\r\n\r\nexport function GetSelectorsUpdateAt(\r\n  options: Pick<RAFirebaseOptions, 'metaFieldCasing' | 'renameMetaFields'>\r\n): string {\r\n  if (options.renameMetaFields && options.renameMetaFields.updated_at) {\r\n    return options.renameMetaFields.updated_at;\r\n  }\r\n  const casing = options.metaFieldCasing;\r\n  const defautCase = 'lastupdate';\r\n  if (!casing) {\r\n    return defautCase;\r\n  }\r\n  if (casing === 'camel') {\r\n    return 'lastUpdate';\r\n  }\r\n  if (casing === 'snake') {\r\n    return 'last_update';\r\n  }\r\n  if (casing === 'pascal') {\r\n    return 'LastUpdate';\r\n  }\r\n  if (casing === 'kebab') {\r\n    return 'last-update';\r\n  }\r\n  return defautCase;\r\n}\r\n\r\nexport function GetSelectorsUpdateBy(\r\n  options: Pick<RAFirebaseOptions, 'metaFieldCasing' | 'renameMetaFields'>\r\n): string {\r\n  if (options.renameMetaFields && options.renameMetaFields.updated_by) {\r\n    return options.renameMetaFields.updated_by;\r\n  }\r\n  const casing = options.metaFieldCasing;\r\n  const defautCase = 'updatedby';\r\n  if (!casing) {\r\n    return defautCase;\r\n  }\r\n  if (casing === 'camel') {\r\n    return 'updatedBy';\r\n  }\r\n  if (casing === 'snake') {\r\n    return 'updated_by';\r\n  }\r\n  if (casing === 'pascal') {\r\n    return 'UpdatedBy';\r\n  }\r\n  if (casing === 'kebab') {\r\n    return 'updated-by';\r\n  }\r\n  return defautCase;\r\n}\r\n\r\nexport function GetSelectorsCreateAt(\r\n  options: Pick<RAFirebaseOptions, 'metaFieldCasing' | 'renameMetaFields'>\r\n): string {\r\n  if (options.renameMetaFields && options.renameMetaFields.created_at) {\r\n    return options.renameMetaFields.created_at;\r\n  }\r\n  const casing = options.metaFieldCasing;\r\n  const defautCase = 'createdate';\r\n  if (!casing) {\r\n    return defautCase;\r\n  }\r\n  if (casing === 'camel') {\r\n    return 'createDate';\r\n  }\r\n  if (casing === 'snake') {\r\n    return 'create_date';\r\n  }\r\n  if (casing === 'pascal') {\r\n    return 'CreateDate';\r\n  }\r\n  if (casing === 'kebab') {\r\n    return 'create-date';\r\n  }\r\n  return defautCase;\r\n}\r\n\r\nexport function GetSelectorsCreateBy(\r\n  options: Pick<RAFirebaseOptions, 'metaFieldCasing' | 'renameMetaFields'>\r\n): string {\r\n  if (options.renameMetaFields && options.renameMetaFields.created_by) {\r\n    return options.renameMetaFields.created_by;\r\n  }\r\n  const casing = options.metaFieldCasing;\r\n  const defautCase = 'createdby';\r\n  if (!casing) {\r\n    return defautCase;\r\n  }\r\n  if (casing === 'camel') {\r\n    return 'createdBy';\r\n  }\r\n  if (casing === 'snake') {\r\n    return 'created_by';\r\n  }\r\n  if (casing === 'pascal') {\r\n    return 'CreatedBy';\r\n  }\r\n  if (casing === 'kebab') {\r\n    return 'created-by';\r\n  }\r\n  return defautCase;\r\n}\r\n","import { FirebaseApp } from 'firebase/app';\r\nimport { Auth, User, UserCredential } from 'firebase/auth';\r\nimport {\r\n  CollectionReference,\r\n  DocumentData,\r\n  DocumentReference,\r\n  DocumentSnapshot,\r\n  FieldValue,\r\n  Firestore,\r\n  OrderByDirection,\r\n  Query,\r\n  QueryDocumentSnapshot,\r\n  WriteBatch,\r\n} from 'firebase/firestore';\r\nimport {\r\n  FirebaseStorage,\r\n  StorageReference,\r\n  TaskState,\r\n  UploadTask,\r\n  UploadTaskSnapshot,\r\n} from 'firebase/storage';\r\n\r\nexport type FireUser = User;\r\nexport type FireApp = FirebaseApp;\r\n\r\nexport type FireStorage = FirebaseStorage;\r\nexport type FireStorageReference = StorageReference;\r\nexport type FireUploadTaskSnapshot = UploadTaskSnapshot;\r\nexport type FireUploadTask = UploadTask;\r\nexport type FireStoragePutFileResult = {\r\n  task: FireUploadTask;\r\n  taskResult: Promise<FireUploadTaskSnapshot>;\r\n  downloadUrl: Promise<string>;\r\n};\r\n\r\nexport type FireAuth = Auth;\r\nexport type FireAuthUserCredentials = UserCredential;\r\n\r\nexport type FireStore = Firestore;\r\nexport type FireStoreBatch = WriteBatch;\r\nexport type FireStoreTimeStamp = FieldValue;\r\nexport type FireStoreDocumentRef = DocumentReference;\r\nexport type FireStoreDocumentSnapshot = DocumentSnapshot<DocumentData>;\r\nexport type FireStoreCollectionRef = CollectionReference;\r\nexport type FireStoreQueryDocumentSnapshot = QueryDocumentSnapshot;\r\nexport type FireStoreQuery = Query;\r\nexport type FireStoreQueryOrder = OrderByDirection;\r\n\r\nexport const TASK_PAUSED = 'paused' as TaskState;\r\nexport const TASK_RUNNING = 'running' as TaskState;\r\nexport const TASK_CANCELED = 'cancelled' as TaskState;\r\n","import {\r\n  doc,\r\n  getDoc,\r\n  getDocs,\r\n  limit,\r\n  query,\r\n  QueryConstraint,\r\n  startAfter,\r\n  startAt,\r\n} from 'firebase/firestore';\r\nimport { ref } from 'firebase/storage';\r\nimport {\r\n  FireStoreCollectionRef,\r\n  FireStoreDocumentSnapshot,\r\n  FireStoreQuery,\r\n} from 'misc/firebase-models';\r\nimport { IFirestoreLogger, messageTypes } from '../../misc';\r\n\r\nexport function setQueryCursor(\r\n  document: FireStoreDocumentSnapshot,\r\n  params: messageTypes.IParamsGetList,\r\n  resourceName: string\r\n) {\r\n  const key = btoa(JSON.stringify({ ...params, resourceName }));\r\n  localStorage.setItem(key, document.id);\r\n\r\n  const allCursorsKey = `ra-firebase-cursor-keys_${resourceName}`;\r\n  const localCursorKeys = localStorage.getItem(allCursorsKey);\r\n  if (!localCursorKeys) {\r\n    localStorage.setItem(allCursorsKey, JSON.stringify([key]));\r\n  } else {\r\n    const cursors: string[] = JSON.parse(localCursorKeys);\r\n    const newCursors = cursors.concat(key);\r\n    localStorage.setItem(allCursorsKey, JSON.stringify(newCursors));\r\n  }\r\n}\r\n\r\nexport async function getQueryCursor(\r\n  collection: FireStoreCollectionRef,\r\n  params: messageTypes.IParamsGetList,\r\n  resourceName: string,\r\n  flogger: IFirestoreLogger\r\n): Promise<FireStoreDocumentSnapshot | false> {\r\n  const key = btoa(JSON.stringify({ ...params, resourceName }));\r\n  const docId = localStorage.getItem(key);\r\n  if (!docId) {\r\n    return false;\r\n  }\r\n\r\n  const docSnapshot = await getDoc(doc(collection, docId));\r\n  flogger.logDocument(1)();\r\n  if (docSnapshot.exists()) {\r\n    return docSnapshot;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function clearQueryCursors(resourceName: string) {\r\n  const allCursorsKey = `ra-firebase-cursor-keys_${resourceName}`;\r\n  const localCursorKeys = localStorage.getItem(allCursorsKey);\r\n  if (localCursorKeys) {\r\n    const cursors: string[] = JSON.parse(localCursorKeys);\r\n    cursors.forEach((cursor) => localStorage.removeItem(cursor));\r\n    localStorage.removeItem(allCursorsKey);\r\n  }\r\n}\r\n\r\nexport async function findLastQueryCursor(\r\n  collection: FireStoreCollectionRef,\r\n  queryConstraints: QueryConstraint[],\r\n  params: messageTypes.IParamsGetList,\r\n  resourceName: string,\r\n  flogger: IFirestoreLogger\r\n) {\r\n  const { page, perPage } = params.pagination;\r\n\r\n  let lastQueryCursor: FireStoreDocumentSnapshot | false = false;\r\n  let currentPage = page - 1;\r\n\r\n  const currentPageParams = {\r\n    ...params,\r\n    pagination: {\r\n      ...params.pagination,\r\n    },\r\n  };\r\n  while (!lastQueryCursor && currentPage > 1) {\r\n    currentPage--;\r\n    currentPageParams.pagination.page = currentPage;\r\n    console.log('getting query cursor currentPage=', currentPage);\r\n    lastQueryCursor = await getQueryCursor(\r\n      collection,\r\n      currentPageParams,\r\n      resourceName,\r\n      flogger\r\n    );\r\n  }\r\n  const pageLimit = (page - currentPage) * perPage;\r\n  const isFirst = currentPage === 1;\r\n\r\n  function getQuery() {\r\n    if (isFirst) {\r\n      return query(collection, ...[...queryConstraints, limit(pageLimit)]);\r\n    } else {\r\n      return query(\r\n        collection,\r\n        ...[...queryConstraints, startAfter(lastQueryCursor), limit(pageLimit)]\r\n      );\r\n    }\r\n  }\r\n\r\n  const newQuery = getQuery();\r\n  const snapshots = await getDocs(newQuery);\r\n  const docsLength = snapshots.docs.length;\r\n  flogger.logDocument(docsLength)();\r\n  const lastDocIndex = docsLength - 1;\r\n  const lastDocRef = snapshots.docs[lastDocIndex];\r\n  return lastDocRef;\r\n}\r\n","import {\r\n  getDocs,\r\n  limit,\r\n  orderBy,\r\n  query,\r\n  QueryConstraint,\r\n  startAfter,\r\n  where,\r\n} from 'firebase/firestore';\r\nimport {\r\n  FireStoreCollectionRef,\r\n  FireStoreQuery,\r\n  FireStoreQueryOrder,\r\n} from 'misc/firebase-models';\r\nimport { IFirestoreLogger, messageTypes } from '../../misc';\r\nimport { findLastQueryCursor, getQueryCursor } from './queryCursors';\r\n\r\ninterface ParamsToQueryOptions {\r\n  filters?: boolean;\r\n  sort?: boolean;\r\n  pagination?: boolean;\r\n}\r\n\r\ninterface QueryPair {\r\n  noPagination: FireStoreQuery;\r\n  withPagination: FireStoreQuery;\r\n}\r\n\r\nconst defaultParamsToQueryOptions = {\r\n  filters: true,\r\n  sort: true,\r\n  pagination: true,\r\n};\r\n\r\nexport async function paramsToQuery<\r\n  TParams extends messageTypes.IParamsGetList\r\n>(\r\n  collection: FireStoreCollectionRef,\r\n  params: TParams,\r\n  resourceName: string,\r\n  flogger: IFirestoreLogger,\r\n  options: ParamsToQueryOptions = defaultParamsToQueryOptions\r\n): Promise<QueryPair> {\r\n  const filterConstraints = options.filters\r\n    ? getFiltersConstraints(params.filter)\r\n    : [];\r\n\r\n  const sortConstraints = options.sort ? getSortConstraints(params.sort) : [];\r\n\r\n  const paginationConstraints = options.pagination\r\n    ? await getPaginationConstraints(\r\n        collection,\r\n        [...filterConstraints, ...sortConstraints],\r\n        params,\r\n        resourceName,\r\n        flogger\r\n      )\r\n    : [];\r\n\r\n  return {\r\n    noPagination: query(\r\n      collection,\r\n      ...[...filterConstraints, ...sortConstraints]\r\n    ),\r\n    withPagination: query(\r\n      collection,\r\n      ...[...filterConstraints, ...sortConstraints, ...paginationConstraints]\r\n    ),\r\n  };\r\n}\r\n\r\nexport function getFiltersConstraints(filters: {\r\n  [fieldName: string]: any;\r\n}): QueryConstraint[] {\r\n  const queries = Object.entries(filters).flatMap(([fieldName, fieldValue]) => {\r\n    const key = fieldName.split('_')[1];\r\n    if (key) {\r\n      if (key == 'equals') return [where(fieldName, '==', fieldValue)];\r\n      if (key == 'notEquals') return [where(fieldName, '!=', fieldValue)];\r\n      if (key == 'gte') return [where(fieldName, '>=', fieldValue)];\r\n      if (key == 'gt') return [where(fieldName, '>', fieldValue)];\r\n      if (key == 'lte') return [where(fieldName, '<=', fieldValue)];\r\n      if (key == 'lt') return [where(fieldName, '<', fieldValue)];\r\n      if (key == 'array-contains')\r\n        return [where(fieldName, 'array-contains', fieldValue)];\r\n      if (key == 'array-contains-any')\r\n        return [where(fieldName, 'array-contains-any', fieldValue)];\r\n      if (key == 'in') return [where(fieldName, 'in', fieldValue)];\r\n      if (key == 'not-in') return [where(fieldName, 'not-in', fieldValue)];\r\n      if (key == 'contains')\r\n        return [\r\n          where(fieldName, '>=', fieldValue.toLocaleLowerCase()),\r\n          where(fieldName, '<=', `${fieldValue.toLocaleLowerCase()}\\uf8ff`),\r\n        ];\r\n    }\r\n    return [where(fieldName, '==', fieldValue)];\r\n  });\r\n  console.log(queries);\r\n  return queries;\r\n}\r\nexport function getSortConstraints(sort: {\r\n  field: string;\r\n  order: string;\r\n}): QueryConstraint[] {\r\n  if (sort != null && sort.field !== 'id') {\r\n    const { field, order } = sort;\r\n    const parsedOrder = order.toLocaleLowerCase() as FireStoreQueryOrder;\r\n    return [orderBy(field, parsedOrder)];\r\n  }\r\n  return [];\r\n}\r\n\r\nasync function getPaginationConstraints<\r\n  TParams extends messageTypes.IParamsGetList\r\n>(\r\n  collectionRef: FireStoreCollectionRef,\r\n  queryConstraints: QueryConstraint[],\r\n  params: TParams,\r\n  resourceName: string,\r\n  flogger: IFirestoreLogger\r\n): Promise<QueryConstraint[]> {\r\n  const { page, perPage } = params.pagination;\r\n\r\n  if (page === 1) {\r\n    return [limit(perPage)];\r\n  } else {\r\n    let queryCursor = await getQueryCursor(\r\n      collectionRef,\r\n      params,\r\n      resourceName,\r\n      flogger\r\n    );\r\n    if (!queryCursor) {\r\n      queryCursor = await findLastQueryCursor(\r\n        collectionRef,\r\n        queryConstraints,\r\n        params,\r\n        resourceName,\r\n        flogger\r\n      );\r\n    }\r\n    return [startAfter(queryCursor), limit(perPage)];\r\n  }\r\n}\r\n\r\nexport function getFullParamsForQuery<\r\n  TParams extends messageTypes.IParamsGetList\r\n>(reactAdminParams: TParams, softdeleteEnabled: boolean): TParams {\r\n  return {\r\n    ...reactAdminParams,\r\n    filter: softdeleteEnabled\r\n      ? {\r\n          deleted: false,\r\n          ...reactAdminParams.filter,\r\n        }\r\n      : reactAdminParams.filter,\r\n  };\r\n}\r\n\r\nexport function getNextPageParams<TParams extends messageTypes.IParamsGetList>(\r\n  params: TParams\r\n): TParams {\r\n  return {\r\n    ...params,\r\n    pagination: {\r\n      ...params.pagination,\r\n      page: params.pagination.page + 1,\r\n    },\r\n  };\r\n}\r\n","import { getCountFromServer, getDocs } from 'firebase/firestore';\r\nimport {\r\n  log,\r\n  messageTypes,\r\n  parseFireStoreDocument,\r\n  recursivelyMapStorageUrls,\r\n} from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient, IResource, ResourceManager } from '../database';\r\nimport { RAFirebaseOptions } from '../options';\r\nimport {\r\n  getFullParamsForQuery,\r\n  getNextPageParams,\r\n  paramsToQuery,\r\n} from './paramsToQuery';\r\nimport { setQueryCursor } from './queryCursors';\r\n\r\nexport class FirebaseLazyLoadingClient {\r\n  constructor(\r\n    private readonly options: RAFirebaseOptions,\r\n    private readonly rm: ResourceManager,\r\n    private client: FireClient\r\n  ) {}\r\n\r\n  public async apiGetList<T extends ra.Record>(\r\n    resourceName: string,\r\n    reactAdminParams: ra.GetListParams\r\n  ): Promise<ra.GetListResult<T>> {\r\n    const r = await this.tryGetResource(resourceName);\r\n    const params = getFullParamsForQuery(\r\n      reactAdminParams,\r\n      !!this.options.softDelete\r\n    );\r\n\r\n    log('apiGetListLazy', { resourceName, params });\r\n\r\n    const { noPagination, withPagination } = await paramsToQuery(\r\n      r.collection,\r\n      params,\r\n      resourceName,\r\n      this.client.flogger\r\n    );\r\n\r\n    const snapshots = await getDocs(withPagination);\r\n\r\n    const resultsCount = snapshots.docs.length;\r\n    if (!resultsCount) {\r\n      log('apiGetListLazy', {\r\n        message: 'There are not records for given query',\r\n      });\r\n      return { data: [], total: 0 };\r\n    }\r\n    this.client.flogger.logDocument(resultsCount)();\r\n\r\n    // tslint:disable-next-line\r\n    const data = snapshots.docs.map((d) => parseFireStoreDocument<T>(d));\r\n\r\n    const nextPageCursor = snapshots.docs[snapshots.docs.length - 1];\r\n    // After fetching documents save queryCursor for next page\r\n    setQueryCursor(nextPageCursor, getNextPageParams(params), resourceName);\r\n    // Hardcoded to allow next pages, as we don't have total number of items\r\n\r\n    let total = await getCountFromServer(noPagination);\r\n\r\n    if (this.options.relativeFilePaths) {\r\n      const parsedData = await Promise.all(\r\n        data.map(async (doc: any) => {\r\n          for (let fieldName in doc) {\r\n            doc[fieldName] = await recursivelyMapStorageUrls(\r\n              this.client.fireWrapper,\r\n              doc[fieldName]\r\n            );\r\n          }\r\n          return doc;\r\n        })\r\n      );\r\n\r\n      log('apiGetListLazy result', {\r\n        docs: parsedData,\r\n        resource: r,\r\n        collectionPath: r.collection.path,\r\n      });\r\n\r\n      return {\r\n        data: parsedData,\r\n        total: total.data().count,\r\n      };\r\n    }\r\n\r\n    log('apiGetListLazy result', {\r\n      docs: data,\r\n      resource: r,\r\n      collectionPath: r.collection.path,\r\n    });\r\n\r\n    return { data, total: total.data().count };\r\n  }\r\n\r\n  public async apiGetManyReference(\r\n    resourceName: string,\r\n    reactAdminParams: messageTypes.IParamsGetManyReference\r\n  ): Promise<messageTypes.IResponseGetManyReference> {\r\n    const r = await this.tryGetResource(resourceName);\r\n    log('apiGetManyReferenceLazy', {\r\n      resourceName,\r\n      resource: r,\r\n      reactAdminParams,\r\n    });\r\n    const filterWithTarget = {\r\n      ...reactAdminParams.filter,\r\n      [reactAdminParams.target]: reactAdminParams.id,\r\n    };\r\n    const params = getFullParamsForQuery(\r\n      {\r\n        ...reactAdminParams,\r\n        filter: filterWithTarget,\r\n      },\r\n      !!this.options.softDelete\r\n    );\r\n\r\n    const { withPagination } = await paramsToQuery(\r\n      r.collection,\r\n      params,\r\n      resourceName,\r\n      this.client.flogger\r\n    );\r\n\r\n    const snapshots = await getDocs(withPagination);\r\n    const resultsCount = snapshots.docs.length;\r\n    this.client.flogger.logDocument(resultsCount)();\r\n    const data = snapshots.docs.map(parseFireStoreDocument);\r\n    if (this.options.relativeFilePaths) {\r\n      const parsedData = await Promise.all(\r\n        data.map(async (doc: any) => {\r\n          for (let fieldName in doc) {\r\n            doc[fieldName] = await recursivelyMapStorageUrls(\r\n              this.client.fireWrapper,\r\n              doc[fieldName]\r\n            );\r\n          }\r\n          return doc;\r\n        })\r\n      );\r\n\r\n      log('apiGetManyReferenceLazy result', {\r\n        docs: parsedData,\r\n        resource: r,\r\n        collectionPath: r.collection.path,\r\n      });\r\n\r\n      return {\r\n        data: parsedData,\r\n        total: data.length,\r\n      };\r\n    }\r\n\r\n    log('apiGetManyReferenceLazy result', {\r\n      docs: data,\r\n      resource: r,\r\n      collectionPath: r.collection.path,\r\n    });\r\n    return { data, total: data.length };\r\n  }\r\n\r\n  private async tryGetResource(\r\n    resourceName: string,\r\n    collectionQuery?: messageTypes.CollectionQueryType\r\n  ): Promise<IResource> {\r\n    return this.rm.TryGetResourcePromise(resourceName, collectionQuery);\r\n  }\r\n}\r\n","import {\r\n  getAbsolutePath,\r\n  log,\r\n  logError,\r\n  logger,\r\n  MakeFirestoreLogger,\r\n  retrieveStatusCode,\r\n} from '../misc';\r\nimport { FireApp } from '../misc/firebase-models';\r\nimport * as ra from '../misc/react-admin-models';\r\nimport { Create, Delete, DeleteMany, Update, UpdateMany } from './commands';\r\nimport { FirebaseWrapper } from './database/firebase/FirebaseWrapper';\r\nimport { FireClient } from './database/FireClient';\r\nimport { RAFirebaseOptions } from './options';\r\nimport { GetList, GetMany, GetManyReference, GetOne } from './queries';\r\n\r\nexport interface IDataProvider extends ra.DataProvider {\r\n  app: FireApp;\r\n}\r\n\r\nexport function DataProvider(\r\n  firebaseConfig: {},\r\n  optionsInput?: RAFirebaseOptions\r\n): IDataProvider {\r\n  const options = optionsInput || {};\r\n  verifyDataProviderArgs(firebaseConfig, options);\r\n\r\n  const flogger = MakeFirestoreLogger(options);\r\n  logger.SetEnabled(!!options?.logging);\r\n  flogger.SetEnabled(!!options?.firestoreCostsLogger?.enabled);\r\n  flogger.ResetCount(!options?.firestoreCostsLogger?.persistCount);\r\n  log('Creating FirebaseDataProvider', {\r\n    firebaseConfig,\r\n    options,\r\n  });\r\n\r\n  const fireWrapper = new FirebaseWrapper(optionsInput, firebaseConfig);\r\n\r\n  async function run<T>(cb: () => Promise<T>) {\r\n    let res: any;\r\n    try {\r\n      res = await cb();\r\n      return res;\r\n    } catch (error) {\r\n      const errorMsg = ((error as any) || '').toString();\r\n      const code = retrieveStatusCode(errorMsg);\r\n      const errorObj = { status: code, message: errorMsg, json: res };\r\n      logError('DataProvider:', error, { errorMsg, code, errorObj });\r\n      throw errorObj;\r\n    }\r\n  }\r\n  const client = new FireClient(fireWrapper, options, flogger);\r\n\r\n  const newProviderApi: IDataProvider = {\r\n    app: fireWrapper.GetApp(),\r\n    getList<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.GetListParams\r\n    ): Promise<ra.GetListResult<RecordType>> {\r\n      return run(() => GetList<RecordType>(resource, params, client));\r\n    },\r\n    getOne<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.GetOneParams\r\n    ): Promise<ra.GetOneResult<RecordType>> {\r\n      return run(() => GetOne<RecordType>(resource, params, client));\r\n    },\r\n    getMany<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.GetManyParams\r\n    ): Promise<ra.GetManyResult<RecordType>> {\r\n      return run(() => GetMany<RecordType>(resource, params, client));\r\n    },\r\n    getManyReference<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.GetManyReferenceParams\r\n    ): Promise<ra.GetManyReferenceResult<RecordType>> {\r\n      return run(() => GetManyReference<RecordType>(resource, params, client));\r\n    },\r\n    update<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.UpdateParams\r\n    ): Promise<ra.UpdateResult<RecordType>> {\r\n      return run(() => Update<RecordType>(resource, params, client));\r\n    },\r\n    updateMany(\r\n      resource: string,\r\n      params: ra.UpdateManyParams\r\n    ): Promise<ra.UpdateManyResult> {\r\n      return run(() => UpdateMany(resource, params, client));\r\n    },\r\n    create<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.CreateParams\r\n    ): Promise<ra.CreateResult<RecordType>> {\r\n      return run(() => Create<RecordType>(resource, params, client));\r\n    },\r\n    delete<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.DeleteParams\r\n    ): Promise<ra.DeleteResult<RecordType>> {\r\n      return run(() => Delete(resource, params, client));\r\n    },\r\n    deleteMany(\r\n      resource: string,\r\n      params: ra.DeleteManyParams\r\n    ): Promise<ra.DeleteManyResult> {\r\n      return run(() => DeleteMany(resource, params, client));\r\n    },\r\n  };\r\n\r\n  return newProviderApi;\r\n}\r\n\r\nfunction verifyDataProviderArgs(\r\n  firebaseConfig: {},\r\n  options?: RAFirebaseOptions\r\n) {\r\n  const hasNoApp = !options || !options.app;\r\n  const hasNoConfig = !firebaseConfig;\r\n  if (hasNoConfig && hasNoApp) {\r\n    throw new Error(\r\n      'Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider'\r\n    );\r\n  }\r\n  if (options && options.rootRef) {\r\n    // Will throw error if rootRef doesn't point to a document\r\n    getAbsolutePath(options.rootRef, 'test');\r\n  }\r\n}\r\n","import {\r\n  filterArray,\r\n  log,\r\n  recursivelyMapStorageUrls,\r\n  sortArray,\r\n} from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database/FireClient';\r\nimport { FirebaseLazyLoadingClient } from '../lazy-loading/FirebaseLazyLoadingClient';\r\n\r\nexport async function GetList<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.GetListParams,\r\n  client: FireClient\r\n): Promise<ra.GetListResult<T>> {\r\n  log('GetList', { resourceName, params });\r\n  const { rm, fireWrapper, options } = client;\r\n\r\n  if (options?.lazyLoading?.enabled) {\r\n    const lazyClient = new FirebaseLazyLoadingClient(options, rm, client);\r\n    return lazyClient.apiGetList<T>(resourceName, params);\r\n  }\r\n\r\n  const filterSafe = params.filter || {};\r\n\r\n  const collectionQuery = filterSafe.collectionQuery;\r\n  delete filterSafe.collectionQuery;\r\n\r\n  const r = await rm.TryGetResource(resourceName, 'REFRESH', collectionQuery);\r\n  const data = r.list;\r\n  if (params.sort != null) {\r\n    const { field, order } = params.sort;\r\n    if (order === 'ASC') {\r\n      sortArray(data, field, 'asc');\r\n    } else {\r\n      sortArray(data, field, 'desc');\r\n    }\r\n  }\r\n  let softDeleted = data;\r\n  if (options.softDelete && !Object.keys(filterSafe).includes('deleted')) {\r\n    softDeleted = data.filter((doc) => !doc.deleted);\r\n  }\r\n  const filteredData = filterArray(softDeleted, filterSafe);\r\n  const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\r\n  const pageEnd = pageStart + params.pagination.perPage;\r\n  const dataPage = filteredData.slice(pageStart, pageEnd) as T[];\r\n  const total = filteredData.length;\r\n\r\n  if (options.relativeFilePaths) {\r\n    const fetchedData = await Promise.all(\r\n      dataPage.map((doc) => recursivelyMapStorageUrls(fireWrapper, doc))\r\n    );\r\n    return {\r\n      data: fetchedData,\r\n      total,\r\n    };\r\n  }\r\n\r\n  return {\r\n    data: dataPage,\r\n    total,\r\n  };\r\n}\r\n","import { log, translateDocFromFirestore } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database/FireClient';\r\n\r\nexport async function GetOne<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.GetOneParams,\r\n  client: FireClient\r\n): Promise<ra.GetOneResult<T>> {\r\n  log('GetOne', { resourceName, params });\r\n  const { rm } = client;\r\n  try {\r\n    const id = params.id + '';\r\n    const dataSingle = await rm.GetSingleDoc(resourceName, id);\r\n    client.flogger.logDocument(1)();\r\n    return { data: dataSingle as T };\r\n  } catch (error) {\r\n    throw new Error(\r\n      'Error getting id: ' + params.id + ' from collection: ' + resourceName\r\n    );\r\n  }\r\n}\r\n","import { doc, getDoc } from 'firebase/firestore';\r\nimport { log, recursivelyMapStorageUrls } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database/FireClient';\r\n\r\nexport async function GetMany<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.GetManyParams,\r\n  client: FireClient\r\n): Promise<ra.GetManyResult<T>> {\r\n  const { rm, options, fireWrapper } = client;\r\n  const r = await rm.TryGetResource(resourceName);\r\n  const ids = params.ids;\r\n  log('GetMany', { resourceName, resource: r, params, ids });\r\n  const matchDocSnaps = await Promise.all(\r\n    ids.map((idObj) => {\r\n      if (typeof idObj === 'string') {\r\n        return getDoc(doc(r.collection, idObj));\r\n      }\r\n      // Will get and resolve reference documents into the current doc\r\n      return getDoc(doc(r.collection, (idObj as any)['___refid']));\r\n    })\r\n  );\r\n  client.flogger.logDocument(ids.length)();\r\n  const matches = matchDocSnaps.map(\r\n    (snap) => ({ ...snap.data(), id: snap.id } as T)\r\n  );\r\n  const permittedData = options.softDelete\r\n    ? matches.filter((row) => !row['deleted'])\r\n    : matches;\r\n  if (options.relativeFilePaths) {\r\n    const data = await Promise.all(\r\n      permittedData.map((d) => recursivelyMapStorageUrls(fireWrapper, d))\r\n    );\r\n    return {\r\n      data,\r\n    };\r\n  }\r\n\r\n  return {\r\n    data: permittedData,\r\n  };\r\n}\r\n","import {\r\n  filterArray,\r\n  log,\r\n  recursivelyMapStorageUrls,\r\n  sortArray,\r\n} from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database/FireClient';\r\n\r\nexport async function GetManyReference<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.GetManyReferenceParams,\r\n  client: FireClient\r\n): Promise<ra.GetManyReferenceResult<T>> {\r\n  const { rm, options, fireWrapper } = client;\r\n  log('GetManyReference', { resourceName, params });\r\n  const filterSafe = params.filter || {};\r\n  const collectionQuery = filterSafe.collectionQuery;\r\n  const r = await rm.TryGetResource(resourceName, 'REFRESH', collectionQuery);\r\n  delete filterSafe.collectionQuery;\r\n  log('apiGetManyReference', { resourceName, resource: r, params });\r\n  const data = r.list;\r\n  const targetField = params.target;\r\n  const targetValue = params.id;\r\n  let softDeleted = data;\r\n  if (options.softDelete) {\r\n    softDeleted = data.filter((doc) => !doc['deleted']);\r\n  }\r\n  const filteredData = filterArray(softDeleted, filterSafe);\r\n  const targetIdFilter: Record<string, ra.Identifier> = {};\r\n  targetIdFilter[targetField] = targetValue;\r\n  const permittedData = filterArray(filteredData, targetIdFilter);\r\n  if (params.sort != null) {\r\n    const { field, order } = params.sort;\r\n    if (order === 'ASC') {\r\n      sortArray(permittedData, field, 'asc');\r\n    } else {\r\n      sortArray(permittedData, field, 'desc');\r\n    }\r\n  }\r\n  const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\r\n  const pageEnd = pageStart + params.pagination.perPage;\r\n  const dataPage = permittedData.slice(pageStart, pageEnd) as T[];\r\n  const total = permittedData.length;\r\n\r\n  if (options.relativeFilePaths) {\r\n    const fetchedData = await Promise.all(\r\n      permittedData.map((doc) => recursivelyMapStorageUrls(fireWrapper, doc))\r\n    );\r\n    return { data: fetchedData, total };\r\n  }\r\n\r\n  return { data: dataPage, total };\r\n}\r\n","import { doc, updateDoc } from 'firebase/firestore';\r\nimport { log } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database';\r\n\r\nexport async function Update<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.UpdateParams,\r\n  client: FireClient\r\n): Promise<ra.UpdateResult<T>> {\r\n  const { rm } = client;\r\n  log('Update', { resourceName, params });\r\n  const id = params.id + '';\r\n  delete params.data.id;\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('Update', { resourceName, resource: r, params });\r\n  const data = await client.parseDataAndUpload(r, id, params.data);\r\n  const docObj = { ...data };\r\n  client.checkRemoveIdField(docObj, id);\r\n  await client.addUpdatedByFields(docObj);\r\n  const docObjTransformed = client.transformToDb(resourceName, docObj, id);\r\n  await updateDoc(doc(r.collection, id), docObjTransformed);\r\n  return {\r\n    data: {\r\n      ...data,\r\n      id: id,\r\n    },\r\n  };\r\n}\r\n","import { doc, updateDoc } from 'firebase/firestore';\r\nimport { log } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database';\r\n\r\nexport async function UpdateMany(\r\n  resourceName: string,\r\n  params: ra.UpdateManyParams,\r\n  client: FireClient\r\n): Promise<ra.UpdateManyResult> {\r\n  const { rm } = client;\r\n  log('UpdateMany', { resourceName, params });\r\n  delete params.data.id;\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('UpdateMany', { resourceName, resource: r, params });\r\n  const ids = params.ids;\r\n  const returnData = await Promise.all(\r\n    ids.map(async (id) => {\r\n      const idStr = id + '';\r\n      const data = await client.parseDataAndUpload(r, idStr, params.data);\r\n      const docObj = { ...data };\r\n      client.checkRemoveIdField(docObj, idStr);\r\n      await client.addUpdatedByFields(docObj);\r\n      const docObjTransformed = client.transformToDb(\r\n        resourceName,\r\n        docObj,\r\n        idStr\r\n      );\r\n      await updateDoc(doc(r.collection, idStr), docObjTransformed);\r\n      return {\r\n        ...data,\r\n        id: idStr,\r\n      };\r\n    })\r\n  );\r\n  return {\r\n    data: returnData,\r\n  };\r\n}\r\n","import { doc, getDoc, setDoc } from 'firebase/firestore';\r\nimport { log } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database/FireClient';\r\n\r\nexport async function Create<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.CreateParams,\r\n  client: FireClient\r\n): Promise<ra.CreateResult<T>> {\r\n  const { rm, fireWrapper } = client;\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('Create', { resourceName, resource: r, params });\r\n  const hasOverridenDocId = params.data && params.data.id;\r\n  log('Create', { hasOverridenDocId });\r\n  if (hasOverridenDocId) {\r\n    const overridenId = params.data.id;\r\n    const exists = (await getDoc(doc(r.collection, overridenId))).exists();\r\n    if (exists) {\r\n      throw new Error(\r\n        `the id:\"${overridenId}\" already exists, please use a unique string if overriding the 'id' field`\r\n      );\r\n    }\r\n\r\n    const createData = await client.parseDataAndUpload(\r\n      r,\r\n      overridenId,\r\n      params.data\r\n    );\r\n    if (!overridenId) {\r\n      throw new Error('id must be a valid string');\r\n    }\r\n    const createDocObj = { ...createData };\r\n    client.checkRemoveIdField(createDocObj, overridenId);\r\n    await client.addCreatedByFields(createDocObj);\r\n    await client.addUpdatedByFields(createDocObj);\r\n    const createDocObjTransformed = client.transformToDb(\r\n      resourceName,\r\n      createDocObj,\r\n      overridenId\r\n    );\r\n    log('Create', { docObj: createDocObj });\r\n    await setDoc(doc(r.collection, overridenId), createDocObjTransformed, {\r\n      merge: false,\r\n    });\r\n    return {\r\n      data: {\r\n        ...createDocObjTransformed,\r\n        id: overridenId,\r\n      },\r\n    };\r\n  }\r\n  const newId = fireWrapper.dbMakeNewId();\r\n  const data = await client.parseDataAndUpload(r, newId, params.data);\r\n  const docObj = { ...data };\r\n  client.checkRemoveIdField(docObj, newId);\r\n  await client.addCreatedByFields(docObj);\r\n  await client.addUpdatedByFields(docObj);\r\n  const docObjTransformed = client.transformToDb(resourceName, docObj, newId);\r\n  await setDoc(doc(r.collection, newId), docObjTransformed, { merge: false });\r\n  return {\r\n    data: {\r\n      ...docObjTransformed,\r\n      id: newId,\r\n    },\r\n  };\r\n}\r\n","import { deleteDoc, doc } from 'firebase/firestore';\r\nimport { log } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database/FireClient';\r\nimport { DeleteSoft } from './Delete.Soft';\r\n\r\nexport async function Delete<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.DeleteParams,\r\n  client: FireClient\r\n): Promise<ra.DeleteResult<T>> {\r\n  const { rm, options } = client;\r\n  if (options.softDelete) {\r\n    return DeleteSoft(resourceName, params, client);\r\n  }\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('apiDelete', { resourceName, resource: r, params });\r\n  try {\r\n    const id = params.id + '';\r\n\r\n    await deleteDoc(doc(r.collection, id));\r\n  } catch (error) {\r\n    throw new Error(error as any);\r\n  }\r\n  return {\r\n    data: params.previousData as T,\r\n  };\r\n}\r\n","import { doc, updateDoc } from 'firebase/firestore';\r\nimport { log, logError } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database';\r\n\r\nexport async function DeleteSoft<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.DeleteParams,\r\n  client: FireClient\r\n): Promise<ra.DeleteResult<T>> {\r\n  const { rm } = client;\r\n  const id = params.id + '';\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('DeleteSoft', { resourceName, resource: r, params });\r\n  const docObj = { deleted: true };\r\n  await client.addUpdatedByFields(docObj);\r\n\r\n  updateDoc(doc(r.collection, id), docObj).catch((error) => {\r\n    logError('DeleteSoft error', { error });\r\n  });\r\n\r\n  return {\r\n    data: params.previousData as T,\r\n  };\r\n}\r\n","import { doc } from 'firebase/firestore';\r\nimport { log } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database';\r\nimport { DeleteManySoft } from './DeleteMany.Soft';\r\n\r\nexport async function DeleteMany(\r\n  resourceName: string,\r\n  params: ra.DeleteManyParams,\r\n  client: FireClient\r\n): Promise<ra.DeleteManyResult> {\r\n  const { options, rm, fireWrapper } = client;\r\n  if (options.softDelete) {\r\n    return DeleteManySoft(resourceName, params, client);\r\n  }\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('DeleteMany', { resourceName, resource: r, params });\r\n  const returnData: ra.Identifier[] = [];\r\n  const batch = fireWrapper.dbCreateBatch();\r\n  for (const id of params.ids) {\r\n    const idStr = id + '';\r\n    const docToDelete = doc(r.collection, idStr);\r\n    batch.delete(docToDelete);\r\n    returnData.push(id);\r\n  }\r\n\r\n  try {\r\n    await batch.commit();\r\n  } catch (error) {\r\n    throw new Error(error as any);\r\n  }\r\n  return { data: returnData };\r\n}\r\n","import { doc, updateDoc } from 'firebase/firestore';\r\nimport { log, logError } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport { FireClient } from '../database';\r\n\r\nexport async function DeleteManySoft(\r\n  resourceName: string,\r\n  params: ra.DeleteManyParams,\r\n  client: FireClient\r\n): Promise<ra.DeleteManyResult> {\r\n  const { rm } = client;\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('DeleteManySoft', { resourceName, resource: r, params });\r\n  const ids = params.ids;\r\n  const returnData = await Promise.all(\r\n    ids.map(async (id) => {\r\n      const idStr = id + '';\r\n      const docObj = { deleted: true };\r\n      await client.addUpdatedByFields(docObj);\r\n      updateDoc(doc(r.collection, idStr), docObj).catch((error) => {\r\n        logError('apiSoftDeleteMany error', { error });\r\n      });\r\n      return idStr;\r\n    })\r\n  );\r\n  return {\r\n    data: returnData,\r\n  };\r\n}\r\n"],"names":["sortArray","data","field","dir","sort","a","b","get","rawB","isAsc","Number","isFinite","rawA","basicSort","toLowerCase","Date","aValue","bValue","filterArray","searchFields","isEmpty","searchObjs","Object","keys","map","fieldName","getSubObjects","value","searchField","searchValue","tree","objectFlatten","leaves","recursivelyWalk","obj","path","key","hasOwnProperty","objVal","currentPath","Array","push","getFieldReferences","filter","row","reduce","acc","cur","res","doesRowMatch","searchThis","toString","includes","isArray","LogNoOp","args","LoggerBase","constructor","title","cacheEnabledKey","this","isEnabled","localStorage","getItem","SetEnabled","setItem","removeItem","log","console","bind","warn","error","KEY_SINGLE","logger","logError","dispatch","eventName","fileName","eventMonitor","document","getElementById","event","CustomEvent","detail","dispatchEvent","REF_INDENTIFIER","translateDocFromFirestore","result","parsedDoc","refdocs","recusivelyCheckObjectValue","input","fieldPath","toDate","index","isInputADocReference","refDocPath","documentReference","id","firestore","parent","recursivelyMapStorageUrls","async","fireWrapper","fieldValue","has","src","getDownloadURL","ref","storage","Promise","all","parseFireStoreDocument","doc","logWarn","refDocs","d","set","applyRefDocs","dataWithRefs","rootRef","relativePath","Error","rootRefValue","join","withSlashes","split","length","slice","joinPaths","translateDocToFirestore","uploads","recusivelyParseObjectValue","fieldDotsPath","refPath","fieldSlashesPath","rawFile","FirebaseWrapper","inputOptions","firebaseConfig","_app","_firestore","_storage","_auth","options","optionsSafe","window","app","getApps","apps","getApp","initializeApp","ObtainFirebaseApp","getFirestore","getStorage","getAuth","dbGetCollection","absolutePath","collection","dbCreateBatch","writeBatch","dbMakeNewId","OnUserLogout","callBack","onAuthStateChanged","user","isLoggedOut","putFile","storagePath","task","uploadBytesResumable","taskResult","rej","then","catch","downloadUrl","t","url","fieldSrc","serverTimestamp","firestoreServerTimestamp","persistenceInput","persistenceResolved","browserLocalPersistence","inMemoryPersistence","browserSessionPersistence","setPersistence","email","password","signInWithEmailAndPassword","signOut","resolve","reject","auth","currentUser","unsubscribe","authGetUserLoggedIn","GetApp","db","optionsInput","persistence","authSetPersistence","params","username","getUserLogin","authSigninEmailPassword","e","HandleAuthLogout","authSignOut","HandleAuthError","errorHttp","retrieveStatusTxt","status","getIdTokenResult","claims","uid","displayName","photoURL","fullName","avatar","authTime","expirationTime","signInProvider","issuedAtTime","token","AuthProvider","VerifyAuthProviderArgs","logging","AuthClient","login","HandleAuthLogin","logout","checkAuth","HandleAuthCheck","checkError","getPermissions","HandleGetPermissions","getIdentity","HandleGetIdentity","getAuthUser","getJWTAuthTime","HandleGetJWTAuthTime","getJWTExpirationTime","HandleGetJWTExpirationTime","getJWTSignInProvider","HandleGetJWTSignInProvider","getJWTClaims","getJWTToken","HandleGetJWTToken","ResourceManager","flogger","resources","resourceName","refresh","collectionQuery","RefreshResource","TryGetResourcePromise","GetResource","resource","initPath","_this$options","lazyLoading","_this$options$lazyLoa","enabled","collectionRef","collectionOrQuery","applyQuery","newDocs","getDocs","forEach","list","logDocument","docs","collectionPath","docId","docSnap","getDoc","exists","getAbsolutePath","hasBeenInited","pathAbsolute","allResources","associateUsersById","getCurrentUserId","getCurrentUserEmail","collRef","FireClient","rm","checkRemoveIdField","dontAddIdFieldToDoc","transformToDb","documentData","r","_this","docPath","u","parseStoragePath","useFileName","fileNameBits","File","name","fileExtension","pop","useFileNamesInStorage","saveFile","link","disableMeta","currentUserIdentifier","getUserIdentifier","createAtSelector","renameMetaFields","created_at","casing","metaFieldCasing","defautCase","GetSelectorsCreateAt","createBySelector","created_by","GetSelectorsCreateBy","AddCreatedByFields","updateAtSelector","GetSelectorsUpdateAt","updated_at","updateBySelector","updated_by","GetSelectorsUpdateBy","AddUpdatedByFields","on","snapshot","progress","bytesTransferred","totalBytes","state","relativeFilePaths","storageError","getQueryCursor","btoa","JSON","stringify","_extends","docSnapshot","defaultParamsToQueryOptions","filters","pagination","paramsToQuery","filterConstraints","getFiltersConstraints","queries","entries","flatMap","where","toLocaleLowerCase","sortConstraints","order","parsedOrder","orderBy","getSortConstraints","queryConstraints","page","perPage","limit","queryCursor","lastQueryCursor","currentPageParams","currentPage","pageLimit","newQuery","query","startAfter","snapshots","docsLength","findLastQueryCursor","getPaginationConstraints","noPagination","withPagination","paginationConstraints","getFullParamsForQuery","reactAdminParams","softdeleteEnabled","deleted","FirebaseLazyLoadingClient","client","tryGetResource","softDelete","resultsCount","message","total","allCursorsKey","localCursorKeys","newCursors","parse","concat","setQueryCursor","getNextPageParams","getCountFromServer","parsedData","count","_this2","target","filterWithTarget","DataProvider","_options$firestoreCos","_options$firestoreCos2","verifyDataProviderArgs","MakeFirestoreLogger","ResetCount","shouldReset","docCount","_options$lazyLoading","incrementBy","incremented","parseInt","currentCountRaw","incrementRead","firestoreCostsLogger","persistCount","run","cb","errorMsg","code","statusTxt","regexResult","exec","retrieveStatusCode","errorObj","json","newProviderApi","getList","apiGetList","filterSafe","TryGetResource","softDeleted","filteredData","pageStart","dataPage","fetchedData","GetList","getOne","GetOne","dataSingle","GetSingleDoc","getMany","GetMany","ids","matchDocSnaps","idObj","snap","permittedData","matches","getManyReference","targetField","targetValue","targetIdFilter","GetManyReference","update","parseDataAndUpload","docObj","addUpdatedByFields","updateDoc","docObjTransformed","Update","updateMany","idStr","UpdateMany","create","Create","hasOverridenDocId","overridenId","createData","createDocObj","addCreatedByFields","createDocObjTransformed","merge","newId","setDoc","delete","Delete","previousData","DeleteSoft","deleteDoc","deleteMany","DeleteManySoft","returnData","batch","docToDelete","commit","DeleteMany"],"mappings":"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"}